- Subplan is for Subquery (sub select)

- query string -> RawStmt -> Query -> PlannedStmt{Plan} -> Plan + PlanState -> ExprEvalStep{ ExprEvalOp } array -> interpret

PostgresMain
`- exec_simple_query
   |- pg_parse_query(query string) -> RawStmt tree
   |  `- raw_parser
   |- pg_analyze_and_rewrite
   |  |- parse_analyze(RawStmt tree) -> Query tree
   |  |  `- transformTopLevelStmt
   |  |     `- transformOptionalSelectInto
   |  |        `- transformStmt
   |  `- pg_rewrite_query
   |- pg_plan_queries
   |  `- pg_plan_query(Query tree) -> PlannedStmt{ Plan tree } tree
   |     `- planner
   |        `- standard_planner
   |           |- subquery_planner // create plans
   |           |- // Select best path
   |           `- create_plan(best_path)
   |              `- create_plan_recurse
   |                 `- case T_ValuesScan: create_scan_plan(best_path) -> Plan
   |                    `- case T_ValuesScan: create_valuesscan_plan -> ValuesScan{ Scan { Plan } }
   `- PortalRun
      `- PortalRunMulti
         `- ProcessQuery
            |- CreateQueryDesc(PlannedStmt tree, Snapshot snapshot) -> QueryDesc{ PlannedStmt tree }
            |- ExecutorStart(QueryDesc)
            |  `- standard_ExecutorStart
            |     `- InitPlan
            |        |- ExecCheckRTPerms // Do permissions checks
            |        |- // Lock relations selected FOR [KEY] UPDATE/SHARE
            |        `- ExecInitNode(Plan tree) -> PlanState tree // constructs PlanState tree from Plan tree
            |           `- case T_ValuesScan: ExecInitValuesScan(ValuesScan node) -> ValuesScanState node
            |              `- set callback ExecProcNode = ExecValuesScan
            |- ExecutorRun(QueryDesc)
            |  `- standard_ExecutorRun
            |     `- ExecutePlan(PlanState tree)
            |        `- ExecProcNode(PlanState node)
            |           `- node->ExecProcNode(node) = ExecValuesScan(PlanState node) // Scans the values lists sequentially and returns the next qualifying tuple (row)
            |              `- ExecScan(ScanState node)
            |                 `- ExecScanFetch(ScanState node)
            |                    `- accessMtd = ValuesNext(ValuesScanState node)
            |                       |- ExecInitExprList
            |                       |  `- ExecInitExpr(Expr node, PlanState parentNode) -> ExprState node // constructs ExprState for Expr
            |                       |     |- ExecInitExprRec(Expr node) // convert Expr to steps...
            |                       |     |  `- ExprEvalPushStep(ExprState node, ExprEvalStep{ ExprEvalOp } step) // add step to node
            |                       |     `- ExecReadyExpr(ExprState)
            |                       |        `- ExecReadyInterpretedExpr
            |                       |           |- set state->evalfunc = ExecInterpExprStillValid
            |                       |           `- set state->evalfunc_private = ExecInterpExpr
            |                       `- ExecEvalExpr
            |                          `- state->evalfunc(state, econtext, isNull) = ExecInterpExprStillValid(ExprState *state, ExprContext *econtext, bool *isNull) -> Datum
            |                             |- state->evalfunc = (ExprStateEvalFunc) state->evalfunc_private;
            |                             `- return state->evalfunc(state, econtext, isNull); = ExecInterpExpr // interpret ExprEvalOp array
            |- ExecutorFinish(QueryDesc)
            `- ExecutorEnd(QueryDesc)
